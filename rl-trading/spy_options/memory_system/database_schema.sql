-- AI Memory System Database Schema
-- Purpose: Store AI decisions, user feedback, and learned patterns
-- This is NOT a trade ledger - it's the AI's memory and learning system

-- Create dedicated schema for AI memory
CREATE SCHEMA IF NOT EXISTS ai_memory;

-- 1. AI Decisions Table
-- Records every suggestion the AI makes with full context
CREATE TABLE ai_memory.decisions (
    decision_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    timestamp TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    -- Model inputs (8 features)
    features FLOAT[] NOT NULL CHECK (array_length(features, 1) = 8),
    feature_names JSONB NOT NULL DEFAULT '["minutes_since_open", "spy_price", "atm_iv", "has_position", "position_pnl", "time_in_position", "risk_score", "minutes_until_close"]',
    
    -- Model outputs
    suggested_action INTEGER NOT NULL CHECK (suggested_action IN (0, 1, 2)), -- 0=hold, 1=call, 2=put
    action_probabilities FLOAT[] CHECK (array_length(action_probabilities, 1) = 3),
    confidence_score FLOAT NOT NULL CHECK (confidence_score >= 0 AND confidence_score <= 1),
    
    -- Market context at decision time
    spy_price NUMERIC(10,2) NOT NULL,
    vix_level NUMERIC(6,2),
    market_regime VARCHAR(50), -- trending_up, trending_down, choppy, etc.
    
    -- Reasoning (generated by model)
    reasoning_factors JSONB, -- {"time_factor": "early_session", "volatility": "elevated", etc}
    constraints_active JSONB, -- {"position_limit": true, "wait_time": false, etc}
    
    -- Metadata
    model_version VARCHAR(50) NOT NULL,
    session_id UUID,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- 2. User Feedback Table
-- Records how user responded to each AI suggestion
CREATE TABLE ai_memory.user_feedback (
    feedback_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    decision_id UUID NOT NULL REFERENCES ai_memory.decisions(decision_id),
    
    -- User response
    accepted BOOLEAN NOT NULL,
    rejection_reason VARCHAR(100), -- strike_too_high, wrong_direction, bad_timing, etc
    user_comment TEXT, -- Free-form feedback
    
    -- If executed
    executed_strike NUMERIC(10,2),
    executed_contracts INTEGER,
    fill_price NUMERIC(10,2),
    
    -- Link to actual trade (if executed)
    trade_ledger_id UUID, -- References trading.trades if needed
    
    -- Timing
    response_time_seconds INTEGER, -- How long user took to decide
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- 3. Market Patterns Table
-- Stores recognized patterns and their outcomes
CREATE TABLE ai_memory.market_patterns (
    pattern_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    pattern_type VARCHAR(50) NOT NULL, -- fed_day, high_vix_morning, trend_reversal, etc
    
    -- Pattern conditions
    spy_range NUMRANGE, -- e.g. [625, 630]
    vix_range NUMRANGE, -- e.g. [15, 20]
    time_of_day_range TSTZRANGE,
    day_of_week INTEGER[], -- 0=Monday, 4=Friday
    
    -- Historical performance
    occurrences INTEGER DEFAULT 0,
    user_acceptance_rate FLOAT, -- % of times user accepted suggestions
    avg_pnl NUMERIC(10,2),
    
    -- Learning
    last_seen TIMESTAMPTZ,
    confidence_level FLOAT DEFAULT 0.5,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- 4. Learned Preferences Table
-- Stores user-specific trading preferences learned over time
CREATE TABLE ai_memory.learned_preferences (
    preference_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    
    -- What was learned
    rule_type VARCHAR(50) NOT NULL, -- timing, direction, strike_distance, etc
    condition JSONB NOT NULL, -- {"time": "before_10:30", "action": "call"}
    user_preference VARCHAR(100) NOT NULL, -- avoid, prefer, neutral
    
    -- Statistical backing
    sample_size INTEGER NOT NULL DEFAULT 1,
    rejection_rate FLOAT,
    confidence FLOAT NOT NULL DEFAULT 0.5,
    
    -- Examples
    example_decisions UUID[], -- Array of decision_ids
    
    -- Metadata
    first_observed TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    last_updated TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    is_active BOOLEAN DEFAULT TRUE
);

-- 5. Session Memory Table
-- Tracks context within a trading session
CREATE TABLE ai_memory.session_memory (
    session_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    session_date DATE NOT NULL,
    
    -- Session stats
    suggestions_made INTEGER DEFAULT 0,
    suggestions_accepted INTEGER DEFAULT 0,
    total_pnl NUMERIC(10,2) DEFAULT 0,
    
    -- Current state
    active_position JSONB, -- {type: "call", strike: 628, entry: 2.50}
    last_action_time TIMESTAMPTZ,
    
    -- Session patterns
    dominant_market_regime VARCHAR(50),
    user_mood VARCHAR(50), -- aggressive, conservative, normal
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- 6. Memory Features Table
-- Pre-computed memory features for fast access
CREATE TABLE ai_memory.memory_features (
    feature_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    compute_time TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    -- Recent history features
    last_5_outcomes INTEGER[], -- [1, -1, 1, 1, 0] for win/loss/neutral
    recent_acceptance_rate FLOAT,
    recent_pnl_trend FLOAT, -- Positive = improving, negative = declining
    
    -- Time-based features
    same_hour_win_rate FLOAT,
    same_weekday_preference JSONB, -- {calls: 0.7, puts: 0.3}
    
    -- Market regime features
    current_regime VARCHAR(50),
    regime_performance JSONB, -- {trending_up: 0.65, choppy: 0.45}
    
    -- User preference features
    strike_distance_preference FLOAT, -- Average preferred strike distance
    risk_tolerance_score FLOAT, -- 0-1 based on recent decisions
    
    -- Cached for performance
    feature_vector FLOAT[], -- Pre-computed 12 memory features
    expires_at TIMESTAMPTZ NOT NULL DEFAULT NOW() + INTERVAL '5 minutes'
);

-- Indexes for performance
CREATE INDEX idx_decisions_timestamp ON ai_memory.decisions(timestamp DESC);
CREATE INDEX idx_decisions_session ON ai_memory.decisions(session_id);
CREATE INDEX idx_decisions_action ON ai_memory.decisions(suggested_action);

CREATE INDEX idx_feedback_decision ON ai_memory.user_feedback(decision_id);
CREATE INDEX idx_feedback_accepted ON ai_memory.user_feedback(accepted);
CREATE INDEX idx_feedback_created ON ai_memory.user_feedback(created_at DESC);

CREATE INDEX idx_patterns_type ON ai_memory.market_patterns(pattern_type);
CREATE INDEX idx_patterns_spy ON ai_memory.market_patterns USING GIST(spy_range);
CREATE INDEX idx_patterns_vix ON ai_memory.market_patterns USING GIST(vix_range);

CREATE INDEX idx_preferences_rule ON ai_memory.learned_preferences(rule_type);
CREATE INDEX idx_preferences_active ON ai_memory.learned_preferences(is_active);

CREATE INDEX idx_memory_features_expires ON ai_memory.memory_features(expires_at);

-- Triggers for auto-updating timestamps
CREATE OR REPLACE FUNCTION ai_memory.update_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_patterns_timestamp
    BEFORE UPDATE ON ai_memory.market_patterns
    FOR EACH ROW
    EXECUTE FUNCTION ai_memory.update_updated_at();

CREATE TRIGGER update_preferences_timestamp
    BEFORE UPDATE ON ai_memory.learned_preferences
    FOR EACH ROW
    EXECUTE FUNCTION ai_memory.update_updated_at();

CREATE TRIGGER update_session_timestamp
    BEFORE UPDATE ON ai_memory.session_memory
    FOR EACH ROW
    EXECUTE FUNCTION ai_memory.update_updated_at();

-- View for current memory state
CREATE VIEW ai_memory.current_context AS
SELECT 
    s.session_id,
    s.session_date,
    s.suggestions_made,
    s.suggestions_accepted,
    CASE 
        WHEN s.suggestions_made > 0 
        THEN s.suggestions_accepted::FLOAT / s.suggestions_made 
        ELSE 0 
    END as acceptance_rate,
    s.total_pnl,
    s.active_position,
    s.dominant_market_regime,
    f.feature_vector as memory_features,
    f.same_hour_win_rate,
    f.recent_pnl_trend
FROM ai_memory.session_memory s
LEFT JOIN ai_memory.memory_features f ON f.expires_at > NOW()
WHERE s.session_date = CURRENT_DATE
ORDER BY s.created_at DESC
LIMIT 1;

-- Function to get similar historical contexts
CREATE OR REPLACE FUNCTION ai_memory.find_similar_contexts(
    current_spy NUMERIC,
    current_vix NUMERIC,
    current_time TIME
)
RETURNS TABLE (
    decision_id UUID,
    similarity_score FLOAT,
    was_accepted BOOLEAN,
    outcome_pnl NUMERIC
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        d.decision_id,
        (
            -- Similarity calculation
            1.0 - (ABS(d.spy_price - current_spy) / 50.0) * 0.4 - 
            COALESCE(ABS(d.vix_level - current_vix) / 10.0, 0) * 0.3 -
            ABS(EXTRACT(HOUR FROM d.timestamp::TIME - current_time)) / 6.0 * 0.3
        ) as similarity_score,
        f.accepted as was_accepted,
        0.0::NUMERIC as outcome_pnl -- Would join with trade ledger for actual P&L
    FROM ai_memory.decisions d
    JOIN ai_memory.user_feedback f ON d.decision_id = f.decision_id
    WHERE 
        d.spy_price BETWEEN current_spy - 10 AND current_spy + 10
        AND d.timestamp > NOW() - INTERVAL '90 days'
    ORDER BY similarity_score DESC
    LIMIT 20;
END;
$$ LANGUAGE plpgsql;

-- Grant permissions (adjust as needed)
GRANT USAGE ON SCHEMA ai_memory TO info;
GRANT ALL ON ALL TABLES IN SCHEMA ai_memory TO info;
GRANT ALL ON ALL SEQUENCES IN SCHEMA ai_memory TO info;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA ai_memory TO info;