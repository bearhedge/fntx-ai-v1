import os
import sys
import psycopg2
from datetime import datetime

sys.path.append(os.path.dirname(os.path.abspath(__file__)))
from config.theta_config import DB_CONFIG

def diagnose_download_issue():
    """Diagnose why only 2 contracts have data"""
    try:
        conn = psycopg2.connect(
            host=DB_CONFIG['host'],
            port=DB_CONFIG['port'],
            database=DB_CONFIG['database'],
            user=DB_CONFIG['user'],
            password=DB_CONFIG['password']
        )
        cursor = conn.cursor()
        
        print("DIAGNOSIS: Why only $475 strike has data for SPY on Sep 30, 2024")
        print("="*80)
        
        # 1. Check download_status table
        print("\n1. DOWNLOAD STATUS:")
        cursor.execute("""
            SELECT 
                symbol, 
                start_date, 
                end_date, 
                data_type, 
                status, 
                records_downloaded,
                error_message,
                started_at,
                completed_at
            FROM theta.download_status
            WHERE symbol = 'SPY'
            ORDER BY started_at DESC
            LIMIT 10;
        """)
        downloads = cursor.fetchall()
        
        if downloads:
            for d in downloads:
                print(f"\nDownload attempt:")
                print(f"  Date range: {d[1]} to {d[2]}")
                print(f"  Data type: {d[3]}")
                print(f"  Status: {d[4]}")
                print(f"  Records: {d[5]}")
                print(f"  Started: {d[7]}")
                print(f"  Completed: {d[8]}")
                if d[6]:
                    print(f"  Error: {d[6]}")
        else:
            print("  No download records found!")
        
        # 2. Check total contracts in database
        print("\n\n2. CONTRACT DISTRIBUTION:")
        cursor.execute("""
            SELECT 
                expiration,
                MIN(strike) as min_strike,
                MAX(strike) as max_strike,
                COUNT(DISTINCT strike) as num_strikes,
                COUNT(*) as total_contracts
            FROM theta.options_contracts
            WHERE symbol = 'SPY'
            AND expiration >= '2024-09-01'
            AND expiration <= '2024-10-31'
            GROUP BY expiration
            ORDER BY expiration;
        """)
        
        contracts = cursor.fetchall()
        print(f"\n{'Expiration':<12} {'Min Strike':<12} {'Max Strike':<12} {'# Strikes':<12} {'Total Contracts'}")
        print("-"*60)
        for c in contracts:
            print(f"{str(c[0]):<12} ${c[1]:<11.2f} ${c[2]:<11.2f} {c[3]:<12} {c[4]}")
        
        # 3. Check OHLC data coverage
        print("\n\n3. OHLC DATA COVERAGE:")
        cursor.execute("""
            SELECT 
                oc.expiration,
                COUNT(DISTINCT oc.strike) as strikes_with_data,
                MIN(oc.strike) as min_strike,
                MAX(oc.strike) as max_strike,
                COUNT(DISTINCT ohlc.datetime::date) as days_with_data,
                MIN(ohlc.datetime) as earliest_data,
                MAX(ohlc.datetime) as latest_data
            FROM theta.options_contracts oc
            JOIN theta.options_ohlc ohlc ON oc.contract_id = ohlc.contract_id
            WHERE oc.symbol = 'SPY'
            AND oc.expiration >= '2024-09-01'
            AND oc.expiration <= '2024-10-31'
            GROUP BY oc.expiration
            ORDER BY oc.expiration;
        """)
        
        coverage = cursor.fetchall()
        if coverage:
            print(f"\n{'Expiration':<12} {'Strikes w/Data':<15} {'Strike Range':<20} {'Days':<6} {'Date Range'}")
            print("-"*80)
            for c in coverage:
                strike_range = f"${c[2]:.0f}-${c[3]:.0f}"
                date_range = f"{c[5].strftime('%m/%d')} to {c[6].strftime('%m/%d')}"
                print(f"{str(c[0]):<12} {c[1]:<15} {strike_range:<20} {c[4]:<6} {date_range}")
        
        # 4. Check specific Sep 30 expiration details
        print("\n\n4. SEPTEMBER 30, 2024 EXPIRATION DETAILS:")
        cursor.execute("""
            SELECT 
                oc.strike,
                oc.option_type,
                COUNT(DISTINCT ohlc.datetime::date) as days_with_data,
                MIN(ohlc.datetime) as first_data,
                MAX(ohlc.datetime) as last_data,
                COUNT(*) as total_records
            FROM theta.options_contracts oc
            LEFT JOIN theta.options_ohlc ohlc ON oc.contract_id = ohlc.contract_id
            WHERE oc.symbol = 'SPY'
            AND oc.expiration = '2024-09-30'
            GROUP BY oc.strike, oc.option_type
            ORDER BY oc.strike, oc.option_type;
        """)
        
        sep30_data = cursor.fetchall()
        print(f"\n{'Strike':<10} {'Type':<6} {'Days':<6} {'First Data':<20} {'Last Data':<20} {'Records'}")
        print("-"*80)
        
        for row in sep30_data[:20]:  # Show first 20
            first = str(row[3]) if row[3] else 'NO DATA'
            last = str(row[4]) if row[4] else 'NO DATA'
            print(f"${row[0]:<9.2f} {row[1]:<6} {row[2] or 0:<6} {first:<20} {last:<20} {row[5] or 0}")
        
        if len(sep30_data) > 20:
            print(f"... and {len(sep30_data) - 20} more contracts")
        
        # 5. Check for gaps in strike coverage
        print("\n\n5. STRIKE COVERAGE ANALYSIS FOR SEP 30:")
        cursor.execute("""
            SELECT 
                strike
            FROM theta.options_contracts
            WHERE symbol = 'SPY'
            AND expiration = '2024-09-30'
            AND option_type = 'C'
            ORDER BY strike;
        """)
        
        strikes = [row[0] for row in cursor.fetchall()]
        if strikes:
            print(f"Total Call strikes available: {len(strikes)}")
            print(f"Strike range: ${min(strikes)} to ${max(strikes)}")
            print(f"$575 strike exists: {'Yes' if 575.0 in strikes else 'No'}")
            
            # Check for gaps
            gaps = []
            for i in range(1, len(strikes)):
                if strikes[i] - strikes[i-1] > 1.01:  # More than $1 gap
                    gaps.append((strikes[i-1], strikes[i]))
            
            if gaps:
                print(f"\nGaps in strike coverage:")
                for gap in gaps:
                    print(f"  Gap between ${gap[0]} and ${gap[1]}")
        
        conn.close()
        
    except Exception as e:
        print(f"Error during diagnosis: {e}")

if __name__ == "__main__":
    diagnose_download_issue()